def to_display_data(message,omdoc=None):
    """wraps the message into the display_data format"""
    if(omdoc):
        return {
            'data': {
                'text/html': message,
                'application/omdoc' : omdoc
            },
            'metadata': {},
            'transient': {},
        }
    else:
        return {
            'data': {
                'text/html': message,
            },
            'metadata': {},
            'transient': {}
        }
    
charMap = {
	"MD" : "❚",
	"DD" : "❙",
	"OD" : "❘",
	"sharp" : "♯",
	"flat" : "♭",
	"U" : "𝒰",
	"ra" : "→",
	"la" : "←",
	"lra" : "↔",
	"rA" : "⇒",
	"lA" : "⇐",
	"lrA" : "⇔",
	"raa" : "⟶",
	"laa" : "⟵",
	"lraa" : "⟷",
	"rAA" : "⟹",
	"lAA" : "⟸",
	"lrAA" : "⟺",
	"hra" : "↪",
	"hla" : "↩",
	"rightarrow" : "→",
	"leftarrow" : "←",
	"leftrightarrow" : "↔",
	"Rightarrow" : "⇒",
	"Leftarrow" : "⇐",
	"Leftrightarrow" : "⇔",
	"hookrightarrow" : "↪",
	"hookleftarrow" : "↩",
	"longrightarrow" : "⟶",
	"longleftarrow" : "⟵",
	"longleftrightarrow" : "⟷",
	"Longrightarrow" : "⟹",
	"Longleftarrow" : "⟸",
	"Longleftrightarrow" : "⟺",
	"bla" : "↦",
	"blA" : "⤇",
	"blaa" : "⟼",
	"blAA" : "⤇",
	"bra" : "↤",
	"brA" : "⤆",
	"braa" : "⟻",
	"brAA" : "⤆",
	"ls" : "⇝",
	"lss" : "⟿",
	"rs" : "⇜",
	"rss" : "⬳",
	"mapsto" : "↦",
	"Mapsto" : "⤇",
	"longmapsto" : "⟼",
	"Longmapsto" : "⤇",
	"mapsfrom" : "↤",
	"Mapsfrom" : "⤆",
	"longmapsfrom" : "⟻",
	"Longmapsfrom" : "⤆",
	"rightsquigarrow" : "⇝",
	"longrightsquigarrow" : "⟿",
	"leftsquigarrow" : "⇜",
	"longleftsquigarrow" : "⬳",
	"lolli" : "⊸",
	"rewrites" : "⟿",
	"uparrow" : "↑",
	"downarrow" : "↓",
	"updownarrow" : "↕",
	"Uparrow" : "⇑",
	"Downarrow" : "⇓",
	"Updownarrow" : "⇕",
	"contra" : "↯",
	"check" : "✓",
	"ast" : "∗",
	"star" : "★",
	"cdot" : "⋅",
	"circ" : "∘",
	"bullet" : "∙",
	"times" : "×",
	"pm" : "±",
	"mp" : "∓",
	"wedge" : "∧",
	"vee" : "∨",
	"cap" : "∩",
	"cup" : "∪",
	"sqcap" : "⊓",
	"sqcup" : "⊔",
	"oplus" : "⊕",
	"ominus" : "⊖",
	"otimes" : "⊗",
	"oslash" : "⊘",
	"oast" : "⊛",
	"ocirc" : "⊚",
	"odot" : "⊙",
	"o0" : "⓪",
	"o1" : "①",
	"o2" : "②",
	"o3" : "③",
	"o4" : "④",
	"o5" : "⑤",
	"o6" : "⑥",
	"o7" : "⑦",
	"o8" : "⑧",
	"o9" : "⑨",
	"bigtimes" : "⨉",
	"bigcirc" : "◯",
	"bigwedge" : "⋀",
	"bigvee" : "⋁",
	"bigcap" : "⋂",
	"bigcup" : "⋃",
	"bigdiamond" : "◇",
	"bigoplus" : "⨁",
	"bigotimes" : "⨂",
	"subset" : "⊂",
	"supset" : "⊃",
	"sq" : "⊆‍",
	"subseteq" : "⊆‍",
	"supseteq" : "⊇",
	"nsubset" : "⊄",
	"nsupset" : "⊅",
	"nsubseteq" : "⊈",
	"nsupseteq" : "⊉",
	"subsetneq" : "⊊",
	"supsetneq" : "⊋",
	"leq" : "≤",
	"geq" : "≥",
	"ll" : "≪",
	"gg" : "≫",
	"nleq" : "≨",
	"ngeq" : "≩",
	"sqsubset" : "⊏",
	"sqsupset" : "⊐",
	"sqsubseteq" : "⊑",
	"sqsupseteq" : "⊒",
	"in" : "∈",
	"nin" : "∉",
	"ni" : "∋",
	"nni" : "∌",
	"neq" : "≠",
	"doteq" : "≐",
	"eq" : "⚌",
	"equiv" : "≡",
	"nequiv" : "≢",
	"sim" : "∼",
	"simeq" : "≃",
	"nsimeq" : "≄",
	"cong" : "≅",
	"ncong" : "≇",
	"approx" : "≈",
	"napprox" : "≉",
	"approxeq" : "≊",
	"triangleright" : "▷",
	"triangleleft" : "◁",
	"blacktriangleright" : "▶",
	"blacktriangleleft" : "◀",
	"der" : "⊦",
	"rightassert" : "⊦",
	"vdash" : "⊢",
	"dashv" : "⊣",
	"models" : "⊧",
	"top" : "⊤",
	"bot" : "⊥",
	"neg" : "¬",
	"forall" : "∀",
	"exists" : "∃",
	"nexists" : "∄",
	"box" : "□",
	"square" : "□",
	"diamond" : "⋄",
	"es" : "∅",
	"emptyset" : "∅",
	"aleph" : "א",
	"infty" : "∞",
	"sum" : "∑",
	"prod" : "∏",
	"coprod" : "∐",
	"amalg" : "∐",
	"comp" : "∁",
	"complement" : "∁",
	"sm" : "∖",
	"setminus" : "∖",
	"colon" : "∶",
	"coloneq" : "≔",
	"langle" : "⟨",
	"rangle" : "⟩",
	"llangle" : "⟪",
	"rrangle" : "⟫",
	"llbracket" : "⟦",
	"rrbracket" : "⟧",
	"lceil" : "⌈",
	"rceil" : "⌉",
	"lfloor" : "⌊",
	"rfloor" : "⌋",
	"ulcorner" : "⌜",
	"urcorner" : "⌝",
	"llcorner" : "⌞",
	"lrcorner" : "⌟",
	"ldots" : "…",
	"vdots" : "⋮",
	"N" : "ℕ",
	"Z" : "ℤ",
	"Q" : "ℚ",
	"R" : "ℝ",
	"C" : "ℂ",
	"B" : "ℬ",
	"pow" : "℘",
	"Alpha" : "Α",
	"Beta" : "Β",
	"Gamma" : "Γ",
	"Delta" : "Δ",
	"Epsilon" : "Ε",
	"Zeta" : "Ζ",
	"Eta" : "Η",
	"Theta" : "Θ",
	"Iota" : "Ι",
	"Kappa" : "Κ",
	"Lambda" : "Λ",
	"Mu" : "Μ",
	"Nu" : "Ν",
	"Xi" : "Ξ",
	"Omikron" : "Ο",
	"Pi" : "Π",
	"Rho" : "Ρ",
	"Sigma" : "Σ",
	"Tau" : "Τ",
	"Upsilon" : "Υ",
	"Phi" : "Φ",
	"Chi" : "Χ",
	"Psi" : "Ψ",
	"Omega" : "Ω",
	"alpha" : "α",
	"beta" : "β",
	"gamma" : "γ",
	"delta" : "δ",
	"epsilon" : "ε",
	"zeta" : "ζ",
	"eta" : "η",
	"theta" : "ϑ",
	"iota" : "ι",
	"kappa" : "κ",
	"lambda" : "λ",
	"mu" : "μ",
	"nu" : "ν",
	"xi" : "ξ",
	"omikron" : "ο",
	"pi" : "π",
	"rho" : "ρ",
	"sigma" : "σ",
	"tau" : "τ",
	"upsilon" : "υ",
	"phi" : "φ",
	"chi" : "χ",
	"psi" : "ψ",
	"omega" : "ω",
	"super0" : "⁰",
	"super1" : "¹  ",
	"super2" : "²",
	"super3" : "³",
	"super4" : "⁴",
	"super5" : "⁵",
	"super6" : "⁶",
	"super7" : "⁷",
	"super8" : "⁸",
	"super9" : "⁹",
	"superplus" : "⁺",
	"superminus" : "⁻",
	"superequal" : "⁼",
	"superopen" : "⁽",
	"superclose" : "⁾",
	"sub0" : "₀",
	"sub1" : "₁",
	"sub2" : "₂",
	"sub3" : "₃",
	"sub4" : "₄",
	"sub5" : "₅",
	"sub6" : "₆",
	"sub7" : "₇",
	"sub8" : "₈",
	"sub9" : "₉",
	"subplus" : "₊",
	"subminus" : "₋",
	"subequal" : "₌",
	"subopen" : "₍",
	"subclose" : "₎",
	"prec" : "≺",
	"preceq" : "≼",
	"succ" : "≻",
	"succeq" : "≽",
	"nabla" : "∇",
	"partial" : "∂",
	"dagger" : "†",
	"int" : "∫",
	"oint" : "∮",
	"ln" : "㏑",
	"perp" : "⊥",
	"parallel" : "∥",
}

# this can be used with extended JSONObject class
# def toPythonDict2(self,JSONObject):
#     """Translates a info.kwarc.mmt.api.utils.JSONObject to a 
#     Python-only dict that can be passed to the widget constructors"""
#     pythonDict = {}
#     for key in JSONObject:
#         keystring = key.value()
#         JV = JSONObject[key].get() # A info.kwarc.mmt.api.utils.JSONValue object
#         if str(JV.getClass()) != "class info.kwarc.mmt.api.utils.JSONArray":
#             # we can handle every JSONValue, except JSONArrays with this
#             pythonDict.update({keystring : JV.value()})
#         else:
#             # here the special case for JSONArrays
#             JSONArray = JV
#             pythonList = []
#             for JSONValue in JSONArray: # JSONValus is also a info.kwarc.mmt.api.utils.JSONValue object
#                 if str(JSONValue.getClass()) == "class info.kwarc.mmt.api.utils.JSONScalaObject":
#                     # at the moment we only use this for widgets. If we are planning on
#                     # sending other ScalaObjects here, we have to discriminate further
#                     WidgetPython = JSONValue.value()
#                     pythonList.append(widgets[WidgetPython.getID()]) 
#                 else:
#                     pythonList.append(JSONValue.value())
#             pythonDict.update({keystring : pythonList})
    
#     return pythonDict

